<details>
<summary>4월 22일 TIL</summary>

## Entity와 Entity Manager

### Entity

영속성을 가진 객체로 DB 테이블에 보관할 대상. 영속 컨텍스트에 속한 객체를 말한다. 이러한 엔티티는 특정한 시점에 DB에 영향을 미치는 쿼리를 실행하게 된다. 

### Entity의 생명주기

- **비영속**  
  - 영속성 컨텍스트와 무관한 새로운 데이터  
  - 클라이언트에서 넘어 온 데이터를 영속화하기 전의 상태
- **영속**  
  - 영속성 컨텍스트에 주입 또는 관리되고 있는 경우  
  - 클라이언트에서 넘어 온 데이터를 영속화 함
- **준영속**  
  - 영속화 되었다가 분리된 경우 (또는 식별자는 잇지만 영속성 컨텍스트에 없는 객체 )
  - 데이터를 수정할 때, 클라이언트 측에서 넘어온 id를 갖고 있는 객체
- **삭제**  
  - 영속성 컨텍스트에서 아예 삭제 된 데이터

### Entity Manager

영속 컨텍스트에 접근하여 엔티티에 대한 DB 작업을 제공한다. 엔티티 매니저의 메서드에 대해 알아보자.

- JPA의 동작은 Entity를 기준으로 돌아가게 되는데, 이 때 Entity를 관리하는 역할을 하는 것  
- JPA는 기본적으로 한 요청 당 하나의 Entity Manager을 사용한다.  
- 각 Entity Manager 들은 정해진 영속성 컨텍스트를 참조한다.

그리고 이렇게 만들어진 Entity Manager로 데이터를 다루려면, 가장 먼저 Entity가 “영속화” 되어 있어야 한다.

> 일반적으로는 Entity Manager 한개 당 하나의 영속성 컨텍스트를 갖지만, **스프링에서는 공통된 영속성 컨텍스트 하나를 여러 Entity Manager가 참조**한다.  

#### **find()**
- 영속 컨텍스트에서 엔티티를 검색하고 없을 경우 DB에서 데이터를 찾아 영속 컨텍스트에 저장한다. 여기서 식별자는 Entity 클래스에서 @Id 애노테이션으로 지정한 값을 사용해야 한다.

#### **persist()**
- 엔티티를 영속 컨텍스트에 저장 후 INSERT 쿼리를 실행한다. 보통 커밋 시점에 INSERT 쿼리를 실행하는데 바로 실행하는 경우도 있다.  
- 트랜잭션 범위 내에서 실행해야 한다. persist() 메서드는 실행 시점에 영속 컨텍스트에 엔티티를 저장하고, 트랜잭션을 commit()하는 시점에 insert 쿼리가 실행되기 때문에, 트랜잭션 범위에서 실행하지 않는다면 실제 DB에 반영되지 않는다.

#### **remove()**
- 엔티티 클래스를 영속 컨텍스트에서 삭제 후 DELETE 쿼리를 실행한다.  
- 트랜잭션 범위 내에서 실행되어야 하며 트랜잭션이 commit() 하는 시점에 delete 쿼리가 실행된다.

### 엔티티 수정

- 엔티티 매니저는 별도의 update 메서드를 제공하지 않는다. JPA는 트랜잭션 범위애서 엔티티 객체의 상태가 변경되면 이를 트랜잭션 커밋 시점에 반영한다. 이 사실을 모르고 사용하면 매우 위험하니 주의한다.

</details>

<details>
<summary>4월 23일 TIL</summary>

# Record를 DTO로 사용하는 이유가 뭔가요?

Record는 Java 16에서 정식 출시된 특별한 유형의 클래스로 **불변성**을 기본으로 한다. 

기존의 클래스와 달리 모든 필드가 final 키워드로 선언되며, 객체 생성 후 변경할 수 없다. 또한 필드 선언만으로 자동으로 생성자, getter, equals(), hashCode(), toString() 등 메서드를 자동으로 생성해 주어 보일러 플레이트 코드를 줄일 수 있다. 이러한 특성으로 인해 멀티 스레드 환경에서 데이터가 의도치 않게 변경되지 않고 안전하게 전달할 수 있다. 

### DTO

```java
public class MemberDto {
	private final String name;
	private final String email;
	private final String gender;

	public MemberDto(String name, String email, String gender) {
		this.name = name;
		this.email = email;
		this.gender = gender;
	}

	public String getName() {
		return name;
	}
	
	public String getEamil() {
		return email;
	}
	
	public String getGender() {
		return gender;

}
```

### Record

```java
// Record. 생성자, getter, hashCode(), equals(), toString() 자동 완성
public record MemberDto(String name, String email, String gender) {}
```

### Record로 생성한 모든 객체는 DTO 인가요?

모든 Record 객체가 DTO인 것은 아니다. Record는 단순히 데이터를 캡슐화하는 역할을 하는데, DTO외에도 값 객체 (Value Objects) 등의 다양한 용도로 사용될 수 있다. 

```java
// 값 객체로 사용
public record Coordinates(double x, double y) {}
```

DTO는 계층 간 데이터 전송을 목적으로 하는 객체이고, VO는 도메인 모델 내에서 특정 값을 표현하는 객체로 사용된다. 따라서, Record는 이 두 가지 모두에 적합하게 사용할 수 있다. 

### Record와 VO를 비교해주세요.

Record와 VO는 모두 객체의 상태가 변경되지 않는 것을 보장한다. 또 데이터를 캡슐화하여 표현하는 데 초점을 맞춘다. 마지막으로 VO는 값 기반의 동등성을 가지며, Record도 동일한 필드 값을 가지면 동일한 객체로 간주된다는 점이 공통점이다. 

VO는 도메인 모델 내에서 특정 개념을 표현하고, 도메인 로직과 밀접하게 관련이 있다. 즉, VO는 비즈니스 로직이나 규칙을 가질 수 있다. 반면에 Record는 단순히 데이터를 캡슐화하여 저장하는데 의미가 있다. 

**결론적으로**, Record는 VO를 구현하는 데 적합하지만, VO의 모든 특성을 완벽히 대체하지는 않는다. VO는 더 넓은 도메인 맥락에서 사용되며, 비즈니스 로직을 포함할 수 있다. 

### Record의 한계는 무엇이 있을까?

Record는 extends를 사용하여 다른 클래스를 상속할 수 없고, 필드가 final로 선언되기 때문에 확장이 어렵다. 또 주로 데이터를 전달하려는 목적으로 설계되었기 때문에 비즈니스 로직을 포함하기에 적절하지 않다. 마지막으로 Java 14 또는 16 이전 버전에 호환이 불가능하다. 

### DTO와 Record 비교하기

**불변성**

Record는 기본적으로 불변성을 가지며, 한 번 생성된 Record 인스턴스의 데이터는 변경할 수 없다. 이러한 불변성 덕분에 데이터는 일관성을 유지하며, 추가적인 코드 없이도 스레드 안전(Threrad-Safe)하다. 

반면 DTO는 일반적으로 가변성을 가지며, 객체가 생성된 후에도 필드를 변경할 수 있다. DTO를 불변으로 만들려면 Setter 메서드를 사용하지 않거나, final 필드를 사용하여 신중하게 설계해야 한다. 

**보일러 플레이트 코드** 

Record의 큰 장점 중 하나는 보일러 플레이트 코드, 즉 반복적인 코드를 크게 줄일 수 있다는 점이다. DTO를 사용할 때는 보통 Getter, Setter, 생성자, equals(), hashCode(), toString() 메서드를 직접 작성해야 하지만, Record는 이러한 메서드를 자동으로 생성한다. 

반대로, DTO는 직접 코드를 작성해야 한다. 롬복 같은 도구를 사용하면 보일러 플레이트 코드를 줄일 수 있지만, Record만큼 간단하지 않다. 

**데이터 표현 방식**

Record는 데이터를 간결하고 직관적으로 표현하는 방법을 제공한다. Record 선언에는 필드만 포함되므로 코드가 더 깔끔하고 읽기 쉽다. 특히 데이터 모델이 많은 프로젝트에서 유지보수가 용이하다. 

**커스터마이징**

DTO의 장점 중 하나는 커스터마이징이 용이하다는 점이다. DTO에서는 데이터 유효성 검사, 데이터 변환 메서드 또는 비즈니스 로직을 추가할 수 있다. 

반면, Record는 커스터마이징이 제한적이다. Record는 가볍고 불변성을 유지하도록 설계되었기 때문에 내부 상태를 수정하거나 복잡한 로직을 쉽게 추가할 수 없다. 만약 데이터 객체에 커스터마이징된 동작 로직이 필요하다면 DTO가 더 유연한 선택이다. 

**함수형 프로그래밍과의 연관성**

함수형 프로그래밍의 핵심 원칙 중 하나는 불변성(Immutability)입니다. 즉, 데이터 객체가 한 번 생성된 후에는 변경되지 않아야 한다는 것이다. Record는 기본적으로 불변이므로 함수형 프로그래밍 원칙과 잘 맞는다. 따라서 불변 데이터 객체를 사용하고자 하는 시스템에 적합한 선택이다. 

반면 DTO는 가변성을 가지며, 불변으로 만들려면 수동적인 설정이 필요하다. DTO는 상태 변경이 흔한 객체 지향 프로그래밍 스타일에 더 적합하다. 

### DTO와 Record는 언제 사용해야 할까?

**DTO를 사용해야 할 때** 

1. **데이터 수정이 필요한 경우**
    
    객체의 데이터를 생성 후 수정해야 할 때는 DTO가 더 적합하다. DTO는 보통 가변적이어서 필드 값을 필요에 따라 변경할 수 있다.  객체의 수명 주기 동안 데이터가 계속해서 업데이트 되는 상황에서 유용하다. 
    
2. **추가적인 동작이나 검증 로직이 필요한 경우**
    
    DTO는 검증, 변환, 또는 추가 메서드 등 맞춤형 동작을 추가하는데 더 유연하다. 데이터 객체가 단순히 데이터를 전달하는 것 이상으로 동작해야 할 때 적합하다. 
    
3. **이전 버전의 Java(16 이전 버전)와 호환이 필요한 경우**
    
    Java 16 이전 버전을 사용하는 프로젝트라면 Record를 사용할 수 없다.
    

**Record를 사용해야 할 때**

1. **간결하고 불변성을 가진 데이터 전달 객체가 필요한 경우**
    
    Record는 가볍고 불변성을 가진 객체로 데이터를 전달해야 할 때 이상적이다. Record는필수적인 메서드들을 자동으로 생성해 주기 때문에 데이터 표현을 간결하고 효율적으로 처리할 수 있다. 
    
    예시 ) MSA에서 서비스 간 데이터를 전달할 때 데이터를 수정할 필요가 없다면 Record가 완벽한 선택일 수 있다. 
    
2. **읽기 전용 데이터 전송이 필요한 경우**
    
    애플리케이션에서 데이터를 전달하기만 하고 수정할 필요가 없다면 Record를 사용하는 것이 좋다. Record는 불변성을 보장하여 데이터 일관성을 유지하기 때문에, 데이터베이스에서 서비스 계층으로 또는 서비스 간 데이터를 전달하는데 적합하다. 
    
3. **최신 자바 애플리케이션에서** 
    
    Java 16 이상을 사용하고 있다면 Record를 충분히 활용할 수 있다. Record는 최신 Java 애플리케이션에서 데이터 표현을 간소화하도록 설계되었으며, 기존 DTO가 가지고 있던 불필요한 반복적인 코드를 줄이는 데 도움이 된다. 
    

### 성능 고려 사항은?

DTO와 Record의 성능을 비교할 때 차이는 크지 않지만, 몇 가지 중요한 요소들을 고려해야 한다. 

**메모리 효율성**

Record는 설계상 간결하므로 DTO보다 메모리를 조금 덜 사용할 수 있다. 그 이유는 Record가 직접 Getter, Setter, equals(), hashCode(), toString() 같은 메서드를 구현할 필요가 없기 때문이다. 이러한 메서드들이 Java 컴파일러에 의해 자동으로 최적화 되어 생성되므로 , 메모리 사용량이 줄어든다. 

**불변성과 스레드 안정성**

Record는 불변이므로 특히 멀티 스레드 환경에서 성능상의 이점을 제공한다. Record는 불변이기 때문에 스레드 간에 공유될 때 동기화나 잠금(locking) 메커니즘이 필요하지 않다. 이는 스레드 간 경쟁으로 성능이 저하되는 상황에서 성능을 향상할 수 있다. 

반면, 가변 DTO를 멀티 스레드 환경에서 사용할 경우, 스레드 안정성을 보장하기 위해 접근을 동기화하거나 다른 메커니즘을 사용해야 하므로 추가적인 부담이 생기고 애플리케이션이 느려질 수 있다. 

**가비지 컬렉션**

DTO와 Record 모두 일반적인 Java 객체이므로 동일한 가비지 컬렉션 처리에 따라 관리된다. 하지만 Record가 더 간결하므로 메모리에 적은 객체가 생성되거나 유지될 수 있어, 가비지 컬렉션이 조금 더 빠르게 이루어질 가능성이 있다. 이는 대량의 데이터 객체를 처리하는 장기 실행 애플리케이션에서 성능 향상에 기여할 수 있다. 

**CPU  오버헤드**

Record는 컴파일러에 의해 자동 생성되며 성능을 최적화하도록 설계되어 있어, 객체 생성, 메서드 호출, 비교 작업에서 CPU 성능이 조금 더 향상될 수 있다. 특히 복잡한 DTO의 경우, 수동으로 구현된 메서드에서 비 효율성이 발생할 수 있는데, Record는 일관되고 최적화된 방식으로 이러한 작업을 처리하므로 효율적이다. 

**실제 성능**

실제로는 DTO와 Record 간의 성능 차이는 대부분의 애플리케이션에서 매우 적거나 무시할 만한 수준일 것이다. Record의 간결함이 특정 시나리오에서 약간의 성능 향상을 가져올 수 있지만, 실제로는 대용량 데이터 처리, 높은 처리량을 요구하는 애플리케이션, 또는 리소스가 제한된 환경(예시 : 모바일 또는 IoT 장치)에서만 눈에 띌 정도의 성능 차이를 경험할 수 있다.

</details>

<details>
<summary>4월 24일 TIL</summary>
## 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?

- 조회용 메서드에 대해 @Transactional 어노테이션 유무의 차이는 OSIV (Open Session In View)가 꺼져있을 때 알 수 있다.
- 절대 불변하는 애들은 안붙여도 되는데 전화번호와 같은 애들은 일관성 유지를 위해서 붙여주는게 좋다.
- **OSIV** 는 영속성 컨텍스트를 View Layer 까지 유지하는 속성으로, 클라이언트의 요청 시점부터 영속성 컨텍스트를 생성하여 Filter / Interceptor - Controller 에서부터 영속성 컨텍스트가 생성되어 유지됨으로써 View Layer 에서도 Entity의 Lazy Loading이 가능하도록 한다.
    - **트랜잭션 범위를 넘어 웹 요청이 완료될 때 까지 열려 있는 상태를 유지하도록 설정하는 기능**
- 기본적으로 별도의 설정을 하지 않는다면 OSIV는 true로 설정되어 있어서 @Transactional 어노테이션 유무의 차이를 알 수 없다.
    - 실제로, OSIV를 켠 상태에서 @Transactional 어노테이션의 유무와 상관없이 다음 **Lazy Loading을 수행**하는 코드의 동작은 Exception 없이 정상적으로 동작한다.
    - 원래는 트랜잭션 범위를 벗어난 **Controller**나 **View** 에서도 엔티티를 사용할 수 있다.
- **OSIV를 false로 설정**한다면 영속성 컨텍스트는 트랜잭션 범위를 벗어나는 순간 Entity는 영속성 컨텍스트의 관리를 받지 않는 준영속 상태가 되어버린다.
    - 트랜잭션이 종료되면 영속성 컨텍스트도 닫힌다.
- 영속성 컨텍스트의 관리를 받지 않는 **준영속 상태**가 된다는 말은 곧 **Lazy Loading의 동작이 불가능하다는 의미**이다.
    - Lazy Loading은 **연관된 엔티티를 실제로 사용할 때 데이터베이스에서 쿼리를 실행하는 방식**이다.
    - 이 과정은 **영속성 컨텍스트가 활성 상태 일 때만 동작**한다.
- OSIV를 false로 설정하고 @Transactional 어노테이션을 제거하였을 때, LazyInitializationException이 발생함을 확인할 수 있다.
- 이렇듯, OSIV가 꺼져있는 상태에서는 @Transactional 어노테이션이 없을 때에 Lazy Loading의 동작을 수행할 수 없다는 문제점이 있으므로 조회용 메서드에 대해서도 @Transactional 어노테이션을 붙여주어야 하는 것이다.
- @Transactional 은 메서드가 호출되는 동안 **트랜잭션을 활성화**하고 영속성 컨텍스트를 열어준다. **따라서 OSIV가 비활성화된 상태에서는 Lazy Loading을 사용하기 위해 조회용 메서드에도 반드시 @Transactional을 붙여야 한다.**
    - @Transactional이 없으면 트랜잭션 범위가 없으므로, Lazy Loading이 동작하지 않는다.
    - Lazy Loading은 영속성 컨텍스트가 열려 있어야 동작함. 따라서 Lazy Loading을 수행하려면 트랜잭션 범위가 필요하다.
- @Transactional 어노테이션을 붙이게 되면 해당 영역에서는 JPA의 스냅샷 유지, flush의 필요성, DB 커넥션을 오래 물고 있는 등의 관리적인 측면이 발생한다.
- 따라서, lazy-loading, replication과 같이 트랜잭션 범위 내에서 수행해야 되는 동작이 있는 경우에 대해서 적절히 @Transactional 어노테이션을 활용하는 것이 좋으며, 무분별하게 @Transactional 어노테이션을 사용하는 것은 위에서 언급했듯이 스냅샷 유지, flush의 필요 등 관리적/메모리적 측면에서 오히려 좋지 않을 수 있고, 커넥션을 오래 가지고 있어 커넥션 부족 등의 문제가 발생할 수 있다.
</details>

<details>
<summary>4월 25일 TIL</summary>
<aside>
❗HOL Blocking 에 대해 설명해 주세요.
</aside>

[HOL Blocking 이란?](https://velog.io/@dnr6054/HOL-Blocking)

**HTTP 에서의 HOL Blocking**

**HTTP/1.1**의 요청-응답 쌍은 항상 순서를 유지하고 동기적으로 수행되어야 한다. 하나의 요청이 처리되고, 응답을 받은 후에 다음 요청을 보낸다. 즉, 이전의 요청이 처리되지 않았다면 그 다음 요청은 보낼 수 없다는 것이다. 

즉, 이전 요청이 막혀버리게 되면 그 다음 요청이 아무리 빨리 처리 될 수 있다고 해도 전체적으로 느려지게 되는 것이다. 이것이 바로 HOL Blocking이다. 

**HTTP/2**의 경우 요청은 하나의 연결에서 병렬적으로 보내질 수 있다. 따라서 첫번째가 시간이 걸려도 그 다음 요청들을 먼저 받아서 보여줄 수 있다는 것이다. 

따라서 HTTP/1.1에서의 HOL Blocking은 HTTP/2에서는 발생하지 않는다고 말할 수 있다.

**TCP에서의 HOL Blocking**

HTTP 요청 / 응답을 TCP 패킷 레벨로 바꾼 것이라고 생각하면 된다. 

TCP는 패킷을 전송할 때에, 전달을 보장하기 때문에 패킷이 손실되면 재전송하게 된다. 그리고 재전송 시 패킷의 순서가 역전되지 않도록 후속 패킷이 대기하게 된다. 따라서 3개의 패킷을 보낸다고 할 때, 앞에서 손실이 발생하면 뒤도 막히게 된다. 

`HTTP/2`로 다중화된 요청은 `TCP`에서는 단순한 패킷이므로 패킷이 막히면 전체가 지연되는 문제는 피할 수 없다. **즉, 여전히 TCP의 특성에 의해 발생하는 지연 문제를 완전히 피할 수 없다는 의미이다.**

</details>


<details>
<summary>4월 28일 TIL</summary>
### 낙관적 락과 비관적 락에 대해 설명하라

---

낙관적 락과 비관적 락은 데이터베이스 트랜잭션에서 동시성 제어를 위한 주요 기법이다. 데이터 무결성을 유지하면서 여러 트랜잭션이 동시에 데이터를 접근할 때 발생할 수 있는 충돌을 해결할 때 사용된다. 

**낙관적 락 (Optimistic Lock)**

데이터 충돌이 적을 것으로 가정하고, 데이터를 읽을 때 락을 설정하지 않고 트랜잭션이 데이터를 수정할 때 충돌이 발생하지 않았는지 확인하는 방식이다. 

- 보통 version과 같은 별도의 구분 컬럼을 사용해서 데이터가 변경되었는지 확인하며, 충돌이 발생하면 데이터베이스가 아닌 애플리케이션에서 직접 롤백하거나 재시도 처리를 해야 한다.

**비관적 락 (Pessimistic Lock)**

데이터 충돌이 많을 것으로 가정하고, 트랜잭션이 시작될 때 공유 락(Shared Lock, S-Lock) 또는 베타 락(Exclusive Lock, X-Lock)을 설정하여 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 하는 방식이다. 

- S-Lock
    
    다른 트랜잭션에서 읽기는 가능하지만 쓰기는 불가능 하다 
    
- X-Lock
    
    다른 트랜잭션에서 읽기, 쓰기 모두 불가능 하다.
    
- 참고
    
    MySQL은 일관된 읽기를 지원하여 X-Lock이 걸려있어도 단순 SELECT로 읽을 수 있다. 
    

**두 방식의 차이점은 무엇인가요 ?**

1. **충돌 가능성**
    1. 낙관적 락은 충돌이 자주 발생하지 않을 것이라고 가정하고, 비관적 락은 충돌이 자주 발생할 것이라고 가정한다. 
2. **데이터베이스 락 사용 여부**
    1. 낙관적 락은 락을 사용하지 않고, 비관적 락은 트랜잭션이 시작될 때 락을 설정한다. 
3. **성능** 
    1. 낙관적 락은 락을 설정하지 않기 때문에 성능이 더 좋을 수 있다. 하지만 충돌이 발생할 경우 롤백하거나 재시도 처리를 해야 하기 때문에 성능이 떨어질 수 있다. 
    2. 비관적 락은 락을 설정하기 때문에 다른 트랜잭션이 대기해야 하며, 이로 인해 성능이 저하될 수 있다.

결론적으로 낙관적 락은 충돌이 발생하면 해결하는 방식이고, 비관적 락은 애초에 충돌을 방지하는 방식이다. 

**언제 어떤 락을 사용하는 것이 유리할까요?**

데이터 충돌이 자주 발생하거나 데이터 무결성이 중요한 경우에는 비관적 락을 사용하는 것이 유리할 수 있다. 조회 작업이 많고 동시 접근이 중요한 경우에는 낙관적 락을 사용하는 것이 유리할 수 있다.
</details>

<details>
<summary>4월 29일 TIL</summary>
# 다중 서버 환경에서 세션 기반 인증 방식을 사용하는 경우 발생할 수 있는 문제점은 무엇인가요?

---

다중 서버 환경에서 세션 기반 인증 방식을 사용하는 경우에는 **세션 불일치 문제**가 발생할 수 있다. 우리가 만약 서버 A,B를 관리하고 있을 때, 로드밸런서는 사용자의 요청을 상황에 맞게 A와 B 중 한 곳으로 전달한다.

유효한 로그인 요청이 A 서버로 처음 도착하면 사용자에 대한 세션 정보는 A 서버에 저장된다. 이후에 해당 사용자의 또 다른 요청이 로드 밸런서에 도착 했을 때 B 서버로 도착하게 되면 사용자의 세션 데이터가 존재하지 않기 때문에 요청이 제대로 처리되지 않는다. 

이를 **세션 불일치 문제**라고 한다. 

## 세션 불일치 문제는 어떻게 해결할 수 있을까?

### 스티키 세션 방식

사용자 요청이 항상 **사용자 세션 정보가 저장된 서버로 가도록 고정하는 방식**이다. 

사용자 요청의 쿠키나 IP를 통해서 어느 서버로 고정 시킬지 결정한다. 

**장점**

- 단순하다.

**단점**

- 특정 서버에 트래픽이 집중될 수 있다는 문제점이 있다
- 사용자 세션 정보를 가지고 있는 서버가 다운되면 해당 서버에 고정된 사용자는 다시 로그인 해야 한다. 즉, 가용성 문제가 있다.

### 세션 클러스터링 방식

**특정 서버에 사용자 세션 정보가 생성될 때, 다른 서버로 정보를 복제**하는 방식이다. 

**장점**

- 여러 서버에 세션 정보를 중복으로 저장하기 때문에, 스티키 세션의 트래픽 몰림 현상과 세션 정보 유실 문제를 해결한다.

**단점**

- 세션 정보를 중복 저장한다는 점에서 메모리를 비효율적으로 사용한다.
- 세션 정보 복제 과정에서 발생하는 네트워크 트래픽 문제가 발생할 수 있다.
- 세션 정보 복제 지연으로 인한 일시적인 세션 정보 유실 문제가 발생할 수 있다.

### 세션 스토리지 분리 방식

**세션 정보를 저장하는 공간을 외부로 분리하는 방식**이다. 

**장점**

클러스터링 방식, 스티키 세션 방식에서 발생하는 문제를 해결할 수 있다. 

**단점**

- 스토리지에 대한 단일 장애 지점이 문제가 될 수 있다.
    - 하나뿐인 세션 스토리지에 장애가 발생하면, 모든 서버가 세션 데이터를 정상적으로 사용할 수 없게 된다. ⇒ 보통 세션 스토리지를 여러개로 구성하는 방식으로 해결한다.
- 클러스터링과 같은 HA 구성으로 단일 장애 지점을 해소해도, 복제 지연으로 인한 일시적인 세션 정보 유실 문제는 발생할 수 있다.
- 외부 스토리지를 관리하기 위한 추가적인 리소스가 요구될 수 있다.
</details>
