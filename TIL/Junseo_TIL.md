<details>
<summary>4월 22일 TIL</summary>

## Entity와 Entity Manager

### Entity

영속성을 가진 객체로 DB 테이블에 보관할 대상. 영속 컨텍스트에 속한 객체를 말한다. 이러한 엔티티는 특정한 시점에 DB에 영향을 미치는 쿼리를 실행하게 된다. 

### Entity의 생명주기

- **비영속**  
  - 영속성 컨텍스트와 무관한 새로운 데이터  
  - 클라이언트에서 넘어 온 데이터를 영속화하기 전의 상태
- **영속**  
  - 영속성 컨텍스트에 주입 또는 관리되고 있는 경우  
  - 클라이언트에서 넘어 온 데이터를 영속화 함
- **준영속**  
  - 영속화 되었다가 분리된 경우 (또는 식별자는 잇지만 영속성 컨텍스트에 없는 객체 )
  - 데이터를 수정할 때, 클라이언트 측에서 넘어온 id를 갖고 있는 객체
- **삭제**  
  - 영속성 컨텍스트에서 아예 삭제 된 데이터

### Entity Manager

영속 컨텍스트에 접근하여 엔티티에 대한 DB 작업을 제공한다. 엔티티 매니저의 메서드에 대해 알아보자.

- JPA의 동작은 Entity를 기준으로 돌아가게 되는데, 이 때 Entity를 관리하는 역할을 하는 것  
- JPA는 기본적으로 한 요청 당 하나의 Entity Manager을 사용한다.  
- 각 Entity Manager 들은 정해진 영속성 컨텍스트를 참조한다.

그리고 이렇게 만들어진 Entity Manager로 데이터를 다루려면, 가장 먼저 Entity가 “영속화” 되어 있어야 한다.

> 일반적으로는 Entity Manager 한개 당 하나의 영속성 컨텍스트를 갖지만, **스프링에서는 공통된 영속성 컨텍스트 하나를 여러 Entity Manager가 참조**한다.  

#### **find()**
- 영속 컨텍스트에서 엔티티를 검색하고 없을 경우 DB에서 데이터를 찾아 영속 컨텍스트에 저장한다. 여기서 식별자는 Entity 클래스에서 @Id 애노테이션으로 지정한 값을 사용해야 한다.

#### **persist()**
- 엔티티를 영속 컨텍스트에 저장 후 INSERT 쿼리를 실행한다. 보통 커밋 시점에 INSERT 쿼리를 실행하는데 바로 실행하는 경우도 있다.  
- 트랜잭션 범위 내에서 실행해야 한다. persist() 메서드는 실행 시점에 영속 컨텍스트에 엔티티를 저장하고, 트랜잭션을 commit()하는 시점에 insert 쿼리가 실행되기 때문에, 트랜잭션 범위에서 실행하지 않는다면 실제 DB에 반영되지 않는다.

#### **remove()**
- 엔티티 클래스를 영속 컨텍스트에서 삭제 후 DELETE 쿼리를 실행한다.  
- 트랜잭션 범위 내에서 실행되어야 하며 트랜잭션이 commit() 하는 시점에 delete 쿼리가 실행된다.

### 엔티티 수정

- 엔티티 매니저는 별도의 update 메서드를 제공하지 않는다. JPA는 트랜잭션 범위애서 엔티티 객체의 상태가 변경되면 이를 트랜잭션 커밋 시점에 반영한다. 이 사실을 모르고 사용하면 매우 위험하니 주의한다.

</details>
